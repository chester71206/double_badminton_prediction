# -*- coding: utf-8 -*-
"""GAT_test_5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TQwOLQTVNjHK24wKzQp8T574dIajE-q1
"""

!pip install torch_geometric

import pandas as pd
import numpy as np
from collections import Counter
import matplotlib.pyplot as plt
# 讀取六個CSV檔案
set1 = pd.read_csv('preprocess1.csv')
set2 = pd.read_csv('preprocess2.csv')
set3 = pd.read_csv('preprocess3.csv')
set4 = pd.read_csv('preprocess4.csv')
set5 = pd.read_csv('preprocess5.csv')
set6 = pd.read_csv('preprocess6.csv')






#combined_data = pd.concat([set1, set2], ignore_index=True)
combined_data = pd.concat([set1, set2,set3, set4,set5, set6], ignore_index=True)

for i in range(0,len(combined_data)):
    if combined_data['ball_round'][i]==1:
        combined_data['hit_x'][i]=combined_data.iloc[i].iloc[19+(ord(combined_data['player'][i])-ord('A'))*2]
        combined_data['hit_y'][i]=combined_data.iloc[i].iloc[20+(ord(combined_data['player'][i])-ord('A'))*2]




for i in range(0,combined_data.shape[0]):
  if(combined_data.at[i, 'ball_type']=="擋小球" or combined_data.at[i, 'ball_type']=="放小球" or combined_data.at[i, 'ball_type']=="小平球"):
    combined_data.at[i, 'ball_type'] = '網前小球'
  elif(combined_data.iloc[i]['ball_type']=="防守回挑"):
    combined_data.at[i, 'ball_type'] = '挑球'
  elif(combined_data.iloc[i]['ball_type']=="防守回抽" or combined_data.iloc[i]['ball_type']=="後場抽平球"):
    combined_data.at[i, 'ball_type'] = "平球"

for i in range(0,len(combined_data)):
    if combined_data['player'][i]=='A':
      combined_data['player'][i]=1
    elif(combined_data['player'][i]=='B'):
      combined_data['player'][i]=2
    elif(combined_data['player'][i]=='C'):
      combined_data['player'][i]=3
    elif(combined_data['player'][i]=='D'):
      combined_data['player'][i]=4
    if(combined_data['ball_type'][i]=='網前小球'):
     combined_data['ball_type'][i]=1
    elif(combined_data['ball_type'][i]=='挑球'):
      combined_data['ball_type'][i]=2
    elif(combined_data['ball_type'][i]=='平球'):
     combined_data['ball_type'][i]=3
    elif(combined_data['ball_type'][i]=='推撲球'):
      combined_data['ball_type'][i]=4
    elif(combined_data['ball_type'][i]=='殺球'):
      combined_data['ball_type'][i]=5
    elif(combined_data['ball_type'][i]=='切球'):
      combined_data['ball_type'][i]=6 #交換位置
    elif(combined_data['ball_type'][i]=='長球'):
      combined_data['ball_type'][i]=7#交換位置
    elif(combined_data['ball_type'][i]=='發長球'):
     combined_data['ball_type'][i]=8
    elif(combined_data['ball_type'][i]=='發短球'):
      combined_data['ball_type'][i]=9

# 14,15 hitx hity
combined_data = combined_data.iloc[:,[1, 2, 8, 10,13,14,16,17,18,19,20,21,22,23,24,25]] #加入return_x return_y


min_x = 26.999998312177805
max_x = 339.0000112887177
min_y = 99.99998030598842
max_y = 784.0000095285399

center_x = (min_x + max_x) / 2
center_y = (min_y + max_y) / 2

double_center_x=(min_x + max_x)
double_center_y=(min_y + max_y)

#combined_data = pd.concat([combined_data, symmetry_data], ignore_index=True)

# count=0
# for i in range(0,len(combined_data)//2):
#     if combined_data['return_x'][i]!=combined_data['return_x'][i+len(combined_data)//2]:
#         count+=1

# print(count)



X_data_list = []
count=0
for i in range(0,combined_data.shape[0]-1):
  if(combined_data['rally'][i]!=combined_data['rally'][i+1] or i==combined_data.shape[0]-2):
    X_sample_list = []
    run=i+1
    if i==combined_data.shape[0]-2:
        run=i+2
    for j in range(count,run):
      X_sample_list.append(combined_data.iloc[j].values)
    X_data_list.append(X_sample_list)
    count=i+1




# X = []
# Y = []
# for i in range(len(X_data_list)):
#         new_sublist = []
#         for j in range(len(X_data_list[i])):
#             if  j>=1 and X_data_list[i][j][0]!=X_data_list[i][j-1][0]:
#               break
#             if X_data_list[i][j][1] <= 9 and X_data_list[i][j][1]!=len(X_data_list[i]):
#                 new_sublist.append(X_data_list[i][j])
#         if(new_sublist!=[]):
#           X.append(new_sublist)
#           Y.append(X_data_list[i][len(new_sublist)])


X = []
Y = []
window_size = 5   # 設定滑動視窗大小

for i in range(len(X_data_list)):
    for j in range(len(X_data_list[i]) - window_size):
        window = X_data_list[i][j:j + window_size]  # 取得滑動視窗的子列表
        X.append(window)
        Y.append(X_data_list[i][j + window_size])


tempX=[]
tempY=[]

count=0
for i in range (0,len(Y)):
    if(Y[i][3]!=7): #第三個index是shot_type
        tempY.append(Y[i])
        tempX.append(X[i])
    else:
        count+=1
print(count)
#print(count)
X=tempX
Y=tempY



tempX=[]
tempY=[]

count=0
for i in range (0,len(X)):
    flag=1
    for j in range(0,len(X[i])):
        if(X[i][j][3]==7):
            flag=0
    if flag==1:
        tempY.append(Y[i])
        tempX.append(X[i])

X=tempX
Y=tempY
# for i in range(len(X)):
#   len_x=len(X[i])
#   if((len_x)<9):#prepadding
#     count=9
#     temp=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ## 因為後面會del row_list的動作，所以多加了三個0
#     for j in range(0,count-len_x):
#       X[i].insert(0,temp)

temp=[]
for i in range(0,len(X)):
  for j in range(0,len(X[i])):
    row_list = list(X[i][j])
    player=X[i][j][2]
    shot_type=X[i][j][3]
    del row_list[1]
    del row_list[1]
    del row_list[1]   #將ball_round刪除
    if(player==1):
      row_list[1:1] = [1,0,0,0]
    elif(player==2):
      row_list[1:1] = [0,1,0,0]
    elif(player==3):
      row_list[1:1] = [0,0,1,0]
    elif(player==4):
      row_list[1:1] = [0,0,0,1]
    if(shot_type==1):
      row_list[5:5] = [1,0,0,0,0,0,0,0]
    elif(shot_type==2):
      row_list[5:5] = [0,1,0,0,0,0,0,0]
    elif(shot_type==3):
      row_list[5:5] = [0,0,1,0,0,0,0,0]
    elif(shot_type==4):
      row_list[5:5] = [0,0,0,1,0,0,0,0]
    elif(shot_type==5):
      row_list[5:5] = [0,0,0,0,1,0,0,0]
    elif(shot_type==6):
      row_list[5:5] = [0,0,0,0,0,1,0,0]
    elif(shot_type==8):
      row_list[5:5] = [0,0,0,0,0,0,1,0]
    elif(shot_type==9):
      row_list[5:5] = [0,0,0,0,0,0,0,1]
    temp.append(row_list)

X=temp


X=np.array(X)
Y=np.array(Y)

X=X.reshape(int(len(X)/window_size),window_size,25)

#X=X.reshape(1011,5,24)

#X=X.reshape(1087,4,24) # 如果看四回合
#X=X.reshape(940,5,24) # 如果看前五回合
#X=X.reshape(819,6,24)# 如果看六回合
#X=X.reshape(712,7,24)# 如果看七回合
X = X.astype(np.float32)
Y = Y.astype(np.float32)




from sklearn.preprocessing import MinMaxScaler
scalerX = MinMaxScaler(feature_range=(0, 1))



for i in range(X.shape[0]):  # 遍历每个数组
  for j in range(X.shape[1]):  # 遍历数组中的每个元素
    X[i, j][13:] = scalerX.fit_transform(X[i, j][13:].reshape(-1, 1)).reshape(-1)  # 特征缩放

#----------------------------------------------------predict


from sklearn.preprocessing import OneHotEncoder
from tensorflow.keras.utils import to_categorical

Y_shot_type = Y[:, 3].reshape(-1, 1)
Y_shot_type=Y_shot_type.astype(int)
Y_shot_type=Y_shot_type-1
n_classes=6
one_hot_encoded = np.zeros((Y_shot_type.shape[0], n_classes))

# 步驟3: 將對應位置設置為1
for i, val in enumerate(Y_shot_type):
    one_hot_encoded[i, val] = 1


#X_train=X[0:124,:,0:14]
#X_val=X[124:164,:,0:16]
#X_test=X[164:198,:,0:16]
# 將已經one-hot編碼的shot type標籤賦值給Y_shot_type
Y_shot_type = one_hot_encoded
# count=0
# for i in range(0,len(Y_shot_type)//2):
#     if Y_shot_type[i]!=Y_shot_type[i+len(Y_shot_type)//2]:
#         count+=1


from sklearn.model_selection import KFold
#kf = KFold(n_splits=10,shuffle=True)
accs = []
history_list = []
num_classes=6 #總共有6種shot_tpye
total_cm = np.zeros((num_classes, num_classes))
val_loss_list = []
train_loss_list=[]
np.set_printoptions(suppress=True)# 設置數字顯示格式，不要有1.6e+02這種顯示方式
#plt.rc('font', family='Microsoft JhengHei')

court_min_x = 26.999998312177805
court_max_x = 339.0000112887177
court_min_y = 99.99998030598842
court_max_y = 784.0000095285399

double_center_x=(court_min_x + court_max_x)
double_center_y=(court_min_y + court_max_y)





#X=X[0:40,:,:]
num_samples = len(X)//2
from sklearn.model_selection import StratifiedKFold
num_folds = 10
skf = StratifiedKFold(n_splits=num_folds, shuffle=False)

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.nn import GATConv, global_mean_pool
from torch_geometric.data import Data, DataLoader
import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay


#print(f"shot_type_input shape: {shot_type_input.shape}")  # 打印數據形狀

# 假設 X 是已處理好的輸入資料，Y_shot_type 是對應的答案
x_coord_index = [17, 19, 21, 23]  # 各球員 x 座標索引
y_coord_index = [18, 20, 22, 24]  # 各球員 y 座標索引
shot_type_index = range(5, 13)    # 回球種類索引
custom_labels = ['1', '2', '3', '4', '5', '6']


shot_type_input = X[:, :, 5:13]  # 形狀為 (942, 5, 8)

train_shot_type_input = torch.tensor(shot_type_input[:800], dtype=torch.float)  # 不用 .view()
test_shot_type_input = torch.tensor(shot_type_input[800:], dtype=torch.float)


train_Y_shot_type=torch.tensor(Y_shot_type[:800])
test_Y_shot_type=torch.tensor(Y_shot_type[800:])

def create_graph(X, y_shot_type):
    G = nx.DiGraph()  # 建立一個有向圖
    node_mapping = {}
    node_counter = 0
    node_features = []

    for t in range(5):  # 對每個時間點 t (總共 5 個時間步長)
        for p in range(4):  # 對 4 個球員分別處理 (A, B, C, D)
            x = X[t, x_coord_index[p]] if t < X.shape[0] else 0  # 取該球員的 x 座標
            y = X[t, y_coord_index[p]] if t < X.shape[0] else 0  # 取該球員的 y 座標
            node_name = f"{t}_{chr(p + 65)}"  # 節點名稱: 時間_球員 (如 0_A, 1_B)
            G.add_node(node_name, pos=(x, y), time=t, player=p)  # 在圖中加節點
            node_mapping[node_name] = node_counter  # 記錄節點映射
            node_counter += 1
            node_features.append([x, y])  # 將 (x, y) 座標作為節點特徵

            # 加自動邊: 表示該選手的移動 (例如從 t-1 時刻移動到 t 時刻)
            if t > 0:
                prev_node_name = f"{t-1}_{chr(p + 65)}"
                G.add_edge(prev_node_name, node_name, movement="movement")

        # 這一段是處理選手之間的擊球邊
        if t < 4:
            for i in range(1, 5):
                if X[t, i] == 1:  # 判斷當前擊球的選手
                    hitter = i - 1
                    if t + 1 < X.shape[0]:
                        for j in range(1, 5):
                            if X[t + 1, j] == 1:  # 判斷下一時刻的接球選手
                                receiver = j - 1
                                shot_type = X[t, shot_type_index]  # 獲取擊球類型
                                # 加一條邊從擊球選手到接球選手，並附上擊球類型
                                G.add_edge(f"{t}_{chr(hitter + 65)}",
                                           f"{t + 1}_{chr(receiver + 65)}",
                                           shot_type=shot_type)

    return G, node_mapping, node_features  # 返回圖，節點映射，節點特徵
graph_data_list = []
for i in range(X.shape[0]):
    G, node_mapping, node_features = create_graph(X[i], Y_shot_type[i])

    # 建立 PyTorch Geometric 的 edge_index
    edge_index = torch.tensor(
        [(node_mapping[u], node_mapping[v]) for u, v in G.edges],
        dtype=torch.long
    ).t().contiguous()

    # 將節點特徵轉換為 PyTorch 張量
    node_features = torch.tensor(node_features, dtype=torch.float)

    # 確保 Y_shot_type 是一維數值
    y = torch.tensor(Y_shot_type[i], dtype=torch.long)  # one-hot 向量
    y = torch.argmax(y, dim=0)  # 取得最大值的索引

    # 建立 Data 物件，包含節點特徵和邊，並加入答案
    data = Data(x=node_features, edge_index=edge_index, y=y)
    graph_data_list.append(data)


class LSTMModel(nn.Module):
    def __init__(self, input_dim, hidden_dim, output_dim):
        super(LSTMModel, self).__init__()
        self.embedding = nn.Linear(input_dim, 128)  # Dense(128, activation="relu")
        self.lstm = nn.LSTM(128, hidden_dim, batch_first=True)
        self.dropout = nn.Dropout(0.2)  # 加入 Dropout，dropout rate = 0.2
        self.fc1 = nn.Linear(hidden_dim, 128)  # Dense(128, activation="relu")
        self.fc2 = nn.Linear(128, output_dim)  # 最終輸出

    def forward(self, x):
        x = F.relu(self.embedding(x))           # 全連結層 (128)
        lstm_out, (h_n, c_n) = self.lstm(x)     # LSTM層
        lstm_out = lstm_out[:, -1, :]           # 取最後一個時間步的輸出
        lstm_out = self.dropout(lstm_out)       # Dropout層
        x = F.relu(self.fc1(lstm_out))          # 全連結層 (128)
        x = self.fc2(x)                         # 最終輸出
        return x

# GAT 模型定義
class GAT(torch.nn.Module):
    def __init__(self, num_classes):
        super(GAT, self).__init__()
        self.conv1 = GATConv(2, 8, heads=4)  # 第一層 GATConv，節點特徵維度 2，輸出 8 個特徵，4 個注意力頭
        self.conv2 = GATConv(8 * 4, 16, heads=1)  # 第二層 GATConv，將上層輸出拼接，輸出 16 個特徵
        self.fc = torch.nn.Linear(16, num_classes)  # 全連接層，用於輸出最終分類

    def forward(self, data):
        x, edge_index = data.x, data.edge_index  # 獲取節點特徵和邊的資訊
        x = F.relu(self.conv1(x, edge_index))  # 第一層 GATConv，激活函數 ReLU
        x = F.dropout(x, training=self.training)  # Dropout
        x = self.conv2(x, edge_index)  # 第二層 GATConv
        x = F.dropout(x, training=self.training)  # Dropout
        x = global_mean_pool(x, data.batch)  # 對每個圖使用全局平均池化
        x = self.fc(x)  # 最後的全連接層
        return x


class CombinedModel(nn.Module):
    def __init__(self, gat_model, lstm_model, lstm_output_dim, num_classes):
        super(CombinedModel, self).__init__()
        self.gat = gat_model
        self.lstm = lstm_model
        self.fc_combined = nn.Linear(16 + lstm_output_dim, num_classes)  # 拼接 GAT 和 LSTM 的輸出

    def forward(self, data, shot_type_input):
        # GAT 模型輸出
        gat_out = self.gat(data)

        lstm_out = self.lstm(shot_type_input)  # LSTM 輸出
        lstm_out = lstm_out[:, -1, :]  # 取最後一個時間步的輸出
        combined_out = torch.cat([gat_out, lstm_out], dim=1)  # 拼接 GAT 和 LSTM 的輸出

        # 通過最終的全連接層進行分類
        output = self.fc_combined(combined_out)
        return output

# 構建 DataLoader
train_loader = DataLoader(graph_data_list[:800], batch_size=32, shuffle=True)
test_loader = DataLoader(graph_data_list[800:], batch_size=32, shuffle=False)

# 訓練 GAT 模型
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
num_classes = 6
# 初始化模型
lstm_model = LSTMModel(input_dim=8, hidden_dim=128, output_dim=128).to(device)
model = GAT(num_classes).to(device)
combined_model = CombinedModel(model, lstm_model, lstm_output_dim=128, num_classes=6).to(device)

# 優化器和損失函數
optimizer = torch.optim.Adam(combined_model.parameters(), lr=0.001)
criterion = torch.nn.CrossEntropyLoss()

# 構建 DataLoader
train_loader = DataLoader(graph_data_list[:800], batch_size=32, shuffle=True)
test_loader = DataLoader(graph_data_list[800:], batch_size=32, shuffle=False)


# 用於儲存指標的列表
train_losses = []
val_losses = []
train_accs = []
val_accs = []
num_epochs=100

for epoch in range(num_epochs):
    combined_model.train()  # 設定為訓練模式
    running_loss = 0.0
    correct = 0
    total = 0

    for batch_data, shot_type_input in zip(train_loader, train_shot_type_input):
        batch_data = batch_data.to(device)
        shot_type_input = shot_type_input.to(device)

        # 前向傳播
        optimizer.zero_grad()
        outputs = combined_model(batch_data, shot_type_input)

        # 計算損失
        loss = criterion(outputs, train_Y_shot_type)
        loss.backward()
        optimizer.step()

        # 計算訓練損失和準確率
        running_loss += loss.item()
        _, predicted = torch.max(outputs, 1)
        correct += (predicted == train_Y_shot_type).sum().item()
        total += train_Y_shot_type.size(0)

    train_loss = running_loss / len(train_loader)
    train_acc = correct / total
    train_losses.append(train_loss)
    train_accs.append(train_acc)

    # 驗證模型
    combined_model.eval()
    val_running_loss = 0.0
    val_correct = 0
    val_total = 0

    with torch.no_grad():
        for batch_data, shot_type_input in zip(test_loader, test_shot_type_input):
            batch_data = batch_data.to(device)
            shot_type_input = shot_type_input.to(device)

            # 前向傳播
            val_outputs = combined_model(batch_data, shot_type_input)

            # 計算損失
            val_loss = criterion(val_outputs, test_Y_shot_type)
            val_running_loss += val_loss.item()

            # 計算驗證準確率
            _, val_predicted = torch.max(val_outputs, 1)
            val_correct += (val_predicted == test_Y_shot_type).sum().item()
            val_total += test_Y_shot_type.size(0)

    val_loss = val_running_loss / len(test_loader)
    val_acc = val_correct / val_total
    val_losses.append(val_loss)
    val_accs.append(val_acc)

    # 輸出每個 epoch 的訓練和驗證結果
    print(f'Epoch [{epoch+1}/{num_epochs}], '
          f'Train Loss: {train_loss:.4f}, Train Accuracy: {train_acc:.4f}, '
          f'Val Loss: {val_loss:.4f}, Val Accuracy: {val_acc:.4f}')

# 訓練完成後顯示混淆矩陣
cm = confusion_matrix(all_labels, all_preds, labels=range(num_classes))

# 使用 ConfusionMatrixDisplay 顯示混淆矩陣
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=custom_labels)
disp.plot(cmap=plt.cm.Blues, values_format='d')
plt.title('Confusion Matrix')
plt.show()

# 繪製訓練和驗證損失圖
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.plot(train_losses, label='Train Loss')
plt.plot(val_losses, label='Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.title('Loss')
plt.legend()

# 繪製訓練和驗證準確度圖
plt.subplot(1, 2, 2)
plt.plot(train_accs, label='Train Accuracy')
plt.plot(val_accs, label='Validation Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy (%)')
plt.title('Accuracy')
plt.legend()

plt.tight_layout()
plt.show()

shot_type_input.shape

print(data.x.shape)  # 節點特徵的形狀
print(data.edge_index.shape)  # 邊的形狀

import torch
import torch.nn.functional as F
from torch_geometric.nn import GATConv, global_mean_pool
from torch_geometric.data import Data, DataLoader
import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

# 假設 X 是已處理好的輸入資料，Y_shot_type 是對應的答案
x_coord_index = [17, 19, 21, 23]  # 各球員 x 座標索引
y_coord_index = [18, 20, 22, 24]  # 各球員 y 座標索引
shot_type_index = range(5, 13)    # 回球種類索引
custom_labels = ['1', '2', '3', '4', '5', '6']

def create_graph(X, y_shot_type):
    G = nx.DiGraph()
    node_mapping = {}
    node_counter = 0
    node_features = []

    for t in range(5):
        for p in range(4):
            # 每個選手的座標
            x = X[t, x_coord_index[p]] if t < X.shape[0] else 0
            y = X[t, y_coord_index[p]] if t < X.shape[0] else 0
            node_name = f"{t}_{chr(p + 65)}"
            G.add_node(node_name, pos=(x, y), time=t, player=p)
            node_mapping[node_name] = node_counter
            node_counter += 1
            node_features.append([x, y])  # 將 x, y 加入節點特徵

            # 加邊：表示該選手的移動（自動邊）
            if t > 0:
                prev_node_name = f"{t-1}_{chr(p + 65)}"
                G.add_edge(prev_node_name, node_name, movement="movement")

        # 當前擊球的情況，跟原代碼相同
        if t < 4:
            for i in range(1, 5):
                if X[t, i] == 1:
                    hitter = i - 1
                    if t + 1 < X.shape[0]:
                        for j in range(1, 5):
                            if X[t + 1, j] == 1:
                                receiver = j - 1
                                shot_type = X[t, shot_type_index]
                                G.add_edge(f"{t}_{chr(hitter + 65)}",
                                           f"{t + 1}_{chr(receiver + 65)}",
                                           shot_type=shot_type)

    return G, node_mapping, node_features

# 繪製圖形的函數
def plot_graph(G):
    # 從節點屬性中提取位置
    pos = {node: (data['pos'][0], data['pos'][1]) for node, data in G.nodes(data=True)}

    # 繪製圖形，不使用箭頭
    plt.figure(figsize=(8, 6))
    nx.draw(G, pos, with_labels=True, node_size=500, font_size=10, font_color='white',
        node_color='blue', edge_color='gray', arrowsize=20, arrowstyle='->')

    # 為邊添加 shot_type 標籤
    edge_labels = nx.get_edge_attributes(G, 'shot_type')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=8)

    plt.title("Badminton Shot Prediction Graph with Shot Types")
    plt.show()

# 假設 create_graph 返回的圖已經包含正確的節點位置資料
index=80
G, _, _ = create_graph(X[index], Y_shot_type[index])  # 使用第一筆資料來創建圖
plot_graph(G)

X[0]

graph_data_list = []
for i in range(X.shape[0]):
    G, node_mapping, node_features = create_graph(X[i])

    # 建立 PyTorch Geometric 的 edge_index
    edge_index = torch.tensor(
        [(node_mapping[u], node_mapping[v]) for u, v in G.edges],
        dtype=torch.long
    ).t().contiguous()

    # 將節點特徵轉換為 PyTorch 張量
    node_features = torch.tensor(node_features, dtype=torch.float)

    # 建立 Data 物件，包含節點特徵
    data = Data(x=node_features, edge_index=edge_index)
    graph_data_list.append(data)

graph_data_list[0]

num_classes

import torch
import torch.nn.functional as F
from torch_geometric.nn import GATConv, global_mean_pool
from torch_geometric.data import Data, DataLoader
import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

# 假設 X 是已處理好的輸入資料，Y_shot_type 是對應的答案
x_coord_index = [17, 19, 21, 23]  # 各球員 x 座標索引
y_coord_index = [18, 20, 22, 24]  # 各球員 y 座標索引
shot_type_index = range(5, 13)    # 回球種類索引
custom_labels = ['1', '2', '3', '4', '5', '6']

def create_graph(X, y_shot_type):
    G = nx.DiGraph()
    node_mapping = {}
    node_counter = 0
    node_features = []

    # 為每個時間點和球員建立節點
    for t in range(5):
        for p in range(4):  # 球員 A, B, C, D
            x = X[t, x_coord_index[p]] if t < X.shape[0] else 0
            y = X[t, y_coord_index[p]] if t < X.shape[0] else 0
            node_name = f"{t}_{chr(p + 65)}"  # 用球員名字 (A, B, C, D)
            G.add_node(node_name, pos=(x, y), time=t, player=p)
            node_mapping[node_name] = node_counter
            node_counter += 1
            node_features.append([x, y])  # 將 x, y 加入節點特徵

        # 連接不同時間點的同一球員節點
        if t < 4:  # 確保時間 t + 1 存在
            for p in range(4):  # 為每個球員添加邊
                current_player = f"{t}_{chr(p + 65)}"
                next_player = f"{t + 1}_{chr(p + 65)}"
                G.add_edge(current_player, next_player, shot_type=None)

        # 建立球員擊球和接球之間的邊
        if t < 4:
            for i in range(1, 5):
                if X[t, i] == 1:
                    hitter = i - 1
                    if t + 1 < X.shape[0]:
                        for j in range(1, 5):
                            if X[t + 1, j] == 1:
                                receiver = j - 1
                                shot_type = X[t, shot_type_index]
                                G.add_edge(f"{t}_{chr(hitter + 65)}",
                                           f"{t + 1}_{chr(receiver + 65)}",
                                           shot_type=shot_type)

    return G, node_mapping, node_features

graph_data_list = []
for i in range(X.shape[0]):
    G, node_mapping, node_features = create_graph(X[i], Y_shot_type[i])

    # 建立 PyTorch Geometric 的 edge_index
    edge_index = torch.tensor(
        [(node_mapping[u], node_mapping[v]) for u, v in G.edges],
        dtype=torch.long
    ).t().contiguous()

    # 將節點特徵轉換為 PyTorch 張量
    node_features = torch.tensor(node_features, dtype=torch.float)

    # 確保 Y_shot_type 是一維數值
    y = torch.tensor(Y_shot_type[i], dtype=torch.long)  # one-hot 向量
    y = torch.argmax(y, dim=0)  # 取得最大值的索引

    # 建立 Data 物件，包含節點特徵和邊，並加入答案
    data = Data(x=node_features, edge_index=edge_index, y=y)
    graph_data_list.append(data)



# 繪製圖形的函數
def plot_graph(G):
    # 從節點屬性中提取位置
    pos = {node: (data['pos'][0], data['pos'][1]) for node, data in G.nodes(data=True)}

    # 繪製圖形
    plt.figure(figsize=(8, 6))
    nx.draw(G, pos, with_labels=True, node_size=500, font_size=10, font_color='white',
            node_color='blue', edge_color='gray', arrowsize=20, arrowstyle='-|>')

    plt.title("Badminton Shot Prediction Graph")
    plt.show()

# 假設 create_graph 返回的圖已經包含正確的節點位置資料
index=40
G, _, _ = create_graph(X[index], Y_shot_type[index])  # 使用第一筆資料來創建圖
plot_graph(G)

